---
title: "Python"
description: "Create a simple MCP server in Python in 15 minutes"
---

Let's build your first MCP server in Python! We'll create a weather server that provides current weather data as a resource and lets Claude fetch forecasts using tools.

<Note>
  This guide uses the OpenWeatherMap API. You'll need a free API key from [OpenWeatherMap](https://openweathermap.org/api) to follow along.
</Note>

## Prerequisites

<Info>
  The following steps are for macOS. Guides for other platforms are coming soon.
</Info>

<Steps>
  <Step title="Install Python">
    You'll need Python 3.10 or higher:

    ```bash
    python --version  # Should be 3.10 or higher
    ```
  </Step>

  <Step title="Install uv via homebrew">
    See https://docs.astral.sh/uv/ for more information.

    ```bash
    brew install uv
    uv --version # Should be 0.4.18 or higher
    ```
  </Step>

  <Step title="Create a new project using the MCP project creator">
    ```bash
    uvx create-mcp-server --path weather_service
    cd weather_service
    # Installs base dependencies
    uv sync --dev --all-extras
    ```
  </Step>

  <Step title="Install additional dependencies">
    ```bash
    uv add requests python-dotenv
    ```
  </Step>

  <Step title="Set up environment">
    Create `.env`:

    ```bash
    OPENWEATHER_API_KEY=your-api-key-here
    ```
  </Step>
</Steps>

## Understanding the starter code

The starter code establishes a basic MCP server structure that we'll build upon to create our weather service. Let's break down its key components:

### Server class definition

```python
class McpServer(Server):
    def __init__(self):
        super().__init__("weather_service")
        self.notes: dict[str, str] = {}
```

This is our main server class that inherits from the base `Server` class. Currently, it initializes with a simple notes dictionary that we'll replace with weather-related functionality.

### Three core primitives

The server implements three fundamental MCP primitives, two of which we'll use for our weather service:

1. **Resources (`@self.list_resources` and `@self.read_resource`)**
   - Will be modified to expose a single weather endpoint for DEFAULT_CITY
   - `list_resources`: Returns current weather resource for DEFAULT_CITY
   - `read_resource`: Fetches and returns current weather data for DEFAULT_CITY
   - Uses custom URI schemes for data access

2. **Tools (`@self.list_tools` and `@self.call_tool`)**
   - Will implement a single "get_forecast" tool
   - Accepts a city name as input
   - Returns weather forecast data for the specified city
   - Uses JSON Schema for input validation

### Server communication

```python
async def main():
    server = McpServer()
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(...)
```

This section handles server initialization and communication setup using stdin/stdout streams.

## Steps to implement our weather server

To transform this starter code into our weather server, we'll:

1. **Set up OpenWeather integration**
   - Add OpenWeather API key configuration
   - Create helper functions for API communication
   - Implement weather data parsing

2. **Implement weather resources**
   - Replace note storage with weather data handling
   - Create weather-specific URI scheme
   - Add current weather fetching for DEFAULT_CITY

3. **Create forecast tool**
   - Remove note-related tools
   - Add "get_forecast" tool implementation
   - Implement city-based forecast fetching
   - Add response formatting

4. **Add error handling**
   - Implement API error management
   - Add input validation for city names
   - Create user-friendly error messages

Let's dive in! 

## Implementing the weather server 

Let's start by modifiying our existing `server.py` to transform it from a notes server into a weather service. We'll go through each section of the code and make the necessary changes.

<Steps>
  <Step title="Updating imports and configuration">
  First, let's add the imports we need at the top of the file:

  ```python
  # Keep existing imports
    import asyncio
    from mcp.server.models import InitializationOptions
    import mcp.types as types
    from mcp.server import NotificationOptions, Server
    from pydantic import AnyUrl
    import mcp.server.stdio

    # Add new imports
    import os
    import json
    import logging
    from datetime import datetime
    import requests
    from dotenv import load_dotenv

    # Add configuration
    load_dotenv()
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("weather-server")

    # API configuration
    API_KEY = os.getenv("OPENWEATHER_API_KEY")
    if not API_KEY:
        raise ValueError("OPENWEATHER_API_KEY environment variable required")

    API_BASE_URL = "http://api.openweathermap.org/data/2.5"
    DEFAULT_CITY = "London"
    CURRENT_WEATHER_ENDPOINT = "weather"
    FORECAST_ENDPOINT = "forecast"
  ```
  </Step>

  <Step title="Update the class initialization">
  
  First, let's modify the class docstring and initialization to remove the notes storage and add our HTTP session:


  ```python
    class McpServer(Server):
        """
        Weather service MCP server implementing two core primitives:
        1. Resources - Current weather data accessed via custom URIs
        2. Tools - Ability to fetch weather forecasts for any city
        """
        def __init__(self):
            super().__init__("weather_service")
            
            # Create reusable session for API calls
            self.http = requests.Session()
            self.http.params = {
                "appid": API_KEY,
                "units": "metric"
            }
    ```
  </Step>

  <Step title="Add weather helper method">
  Next, let's add a helper method to fetch weather data that both our resource and tool handlers will use:

  ```python
  async def fetch_weather(self, city: str) -> dict:
        """Helper method to fetch current weather data."""
        response = self.http.get(
            f"{API_BASE_URL}/weather",
            params={"q": city}
        )
        response.raise_for_status()
        data = response.json()

        return {
            "temperature": data["main"]["temp"],
            "conditions": data["weather"][0]["description"],
            "humidity": data["main"]["humidity"],
            "wind_speed": data["wind"]["speed"],
            "timestamp": datetime.now().isoformat()
        }
  ```
  </Step>

  <Step title="Update resource handlers">
    Now, let's replace the note-related resource handlers with weather ones:

    ```python
    # RESOURCE HANDLERS
    @self.list_resources()
    async def handle_list_resources(self) -> list[types.Resource]:
        """List available weather resources."""
        uri = AnyUrl(f"weather://{DEFAULT_CITY}/current")
        return [
            types.Resource(
                uri=uri,
                name=f"Current weather in {DEFAULT_CITY}",
                mimeType="application/json",
                description="Real-time weather data"
            )
        ]

    @self.read_resource()
    async def handle_read_resource(self, uri: AnyUrl) -> str:
        """Read current weather data for a city."""
        if str(uri).startswith("weather://") and str(uri).endswith("/current"):
            city = str(uri).split("/")[-2]
        else:
            raise ValueError(f"Unknown resource: {uri}")

        try:
            weather_data = await self.fetch_weather(city)
            return json.dumps(weather_data, indent=2)
        except requests.RequestException as e:
            raise RuntimeError(f"Weather API error: {str(e)}")
    ```
  </Step>

  <Step title="Remove prompt handlers">
  Remove the entire prompt section from the starter code - we won't be using prompts in our weather service.
  </Step>

  <Step title="Update tool handlers">
  Finally, let's replace the note-adding tool with our weather forecast tool:

    ```python
    # TOOL HANDLERS
    @self.list_tools()
    async def handle_list_tools(self) -> list[types.Tool]:
        """List available weather tools."""
        return [
            types.Tool(
                name="get_forecast",
                description="Get weather forecast for a city",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "city": {
                            "type": "string",
                            "description": "City name"
                        },
                        "days": {
                            "type": "number",
                            "description": "Number of days (1-5)",
                            "minimum": 1,
                            "maximum": 5
                        }
                    },
                    "required": ["city"]
                }
            )
        ]

    @self.call_tool()
    async def handle_call_tool(
        self, name: str, arguments: dict | None
    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
        """Handle tool calls for weather forecasts."""
        if name != "get_forecast":
            raise ValueError(f"Unknown tool: {name}")

        if not isinstance(arguments, dict) or "city" not in arguments:
            raise ValueError("Invalid forecast arguments")

        city = arguments["city"]
        days = min(int(arguments.get("days", 3)), 5)

        try:
            response = self.http.get(
                f"{API_BASE_URL}/{FORECAST_ENDPOINT}",
                params={
                    "q": city,
                    "cnt": days * 8  # API returns 3-hour intervals
                }
            )
            response.raise_for_status()
            data = response.json()

            forecasts = []
            for i in range(0, len(data["list"]), 8):
                day_data = data["list"][i]
                forecasts.append({
                    "date": day_data["dt_txt"].split()[0],
                    "temperature": day_data["main"]["temp"],
                    "conditions": day_data["weather"][0]["description"]
                })

            return [
                types.TextContent(
                    type="text",
                    text=json.dumps(forecasts, indent=2)
                )
            ]
        except requests.RequestException as e:
            logger.error(f"Weather API error: {str(e)}")
            raise RuntimeError(f"Weather API error: {str(e)}")
    ```
  </Step>
</Steps>

## Connect to Claude Desktop

Now that our server is implemented, let's make sure Claude desktop can talk to it properly.

<Note>
Note that this step is unnecessary if you've opted to install the server into Claude.app with the MCP project creator script.
</Note>

<Steps>
  <Step title="Update Claude config">
    Add to `claude_desktop_config.json`:

    ```json
    {
      "mcpServers": {
        "weather": {
          "command": "uv",
          "args": "--directory path/to/your/project run weather-service",
          "env": {
            "OPENWEATHER_API_KEY": "your-api-key",
          }
        }
      }
    }
    ```
  </Step>

  <Step title="Restart Claude">
    1. Quit Claude completely

    2. Start Claude again

    3. Look for your weather server in the ðŸ”Œ menu
  </Step>
</Steps>

## Try it out!

<AccordionGroup>
  <Accordion title="Check Current Weather" active>
    Ask Claude:

    ```
    What's the current weather in San Francisco? Can you analyze the conditions and tell me if it's a good day for outdoor activities?
    ```
  </Accordion>

  <Accordion title="Get a Forecast">
    Ask Claude:

    ```
    Can you get me a 5-day forecast for Tokyo and help me plan what clothes to pack for my trip?
    ```
  </Accordion>

  <Accordion title="Compare Weather">
    Ask Claude:

    ```
    Can you analyze the forecast for both Tokyo and San Francisco and tell me which city would be better for outdoor photography this week?
    ```
  </Accordion>
</AccordionGroup>

## Advanced features

<Steps>
  <Step title="Understanding Request Context">
    The request context provides access to the current request's metadata and the active client session. Access it through `server.request_context`:

    ```python
    @app.call_tool()
    async def call_tool(name: str, arguments: Any) -> Sequence[TextContent]:
        # Access the current request context
        ctx = self.request_context

        # Get request metadata like progress tokens
        if progress_token := ctx.meta.progressToken:
            # Send progress notifications via the session
            await ctx.session.send_progress_notification(
                progress_token=progress_token,
                progress=0.5,
                total=1.0
            )

        # Sample from the LLM client
        result = await ctx.session.create_message(
            messages=[
                SamplingMessage(
                    role="user",
                    content=TextContent(
                        type="text",
                        text="Analyze this weather data: " + json.dumps(arguments)
                    )
                )
            ],
            max_tokens=100
        )

        return [TextContent(type="text", text=result.content.text)]
    ```
  </Step>

  <Step title="Add caching">
    ```python
    # Cache settings
    cache_timeout = timedelta(minutes=15)
    last_cache_time = None
    cached_weather = None

    async def fetch_weather(city: str) -> dict[str, Any]:
        global cached_weather, last_cache_time

        now = datetime.now()
        if (cached_weather is None or
            last_cache_time is None or
            now - last_cache_time > cache_timeout):

            response = http.get(
                f"{API_BASE_URL}/{CURRENT_WEATHER_ENDPOINT}",
                params={"q": city}
            )
            response.raise_for_status()
            data = response.json()

            cached_weather = {
                "temperature": data["main"]["temp"],
                "conditions": data["weather"][0]["description"],
                "humidity": data["main"]["humidity"],
                "wind_speed": data["wind"]["speed"],
                "timestamp": datetime.now().isoformat()
            }
            last_cache_time = now

        return cached_weather
    ```
  </Step>

  <Step title="Add progress notifications">
    ```python
    @self.call_tool()
    async def call_tool(self, name: str, arguments: Any) -> CallToolResult:
        if progress_token := self.request_context.meta.progressToken:
            # Send progress notifications
            await self.request_context.session.send_progress_notification(
                progress_token=progress_token,
                progress=1,
                total=2
            )

            # Fetch data...

            await self.request_context.session.send_progress_notification(
                progress_token=progress_token,
                progress=2,
                total=2
            )

        # Rest of the method implementation...
    ```
  </Step>

  <Step title="Add logging support">
    ```python
    import logging

    class WeatherServer(Server):
        def __init__(self):
            super().__init__("example-weather-server")
            self.logger = logging.getLogger("weather-server")
            self.logger.setLevel(logging.INFO)

        @self.set_logging_level()
        async def set_logging_level(self, level: LoggingLevel) -> EmptyResult:
            self.logger.setLevel(level.upper())
            await self.request_context.session.send_log_message(
                level="info",
                data=f"Log level set to {level}",
                logger="weather-server"
            )
            return EmptyResult()

        # Use self.logger for logging throughout the class methods
        # For example:
        # self.logger.info("Weather data fetched successfully")
        # self.logger.error(f"Error fetching weather data: {str(e)}")
    ```
  </Step>

  <Step title="Add resource templates">
    ```python
    @self.list_resources()
    async def list_resources(self) -> ListResourcesResult:
        return ListResourcesResult(
            resources=[...],
            resourceTemplates=[
                ResourceTemplate(
                    uriTemplate="weather://{city}/current",
                    name="Current weather for any city",
                    mimeType="application/json"
                )
            ]
        )
    ```
  </Step>
</Steps>

## Testing

<Steps>
  <Step title="Create test file">
  Create `tests/weather_test.py`:

  ```python
  import pytest
  import os
  from unittest.mock import patch, Mock
  from datetime import datetime
  import json
  from pydantic import AnyUrl
  os.environ["OPENWEATHER_API_KEY"] = "TEST"

  from weather_service.server import (
      fetch_weather,
      read_resource,
      call_tool,
      list_resources,
      list_tools,
      DEFAULT_CITY
  )

  @pytest.fixture
  def mock_weather_response():
      return {
          "main": {
              "temp": 20.5,
              "humidity": 65
          },
          "weather": [
              {"description": "scattered clouds"}
          ],
          "wind": {
              "speed": 3.6
          }
      }

  @pytest.fixture
  def mock_forecast_response():
      return {
          "list": [
              {
                  "dt_txt": "2024-01-01 12:00:00",
                  "main": {"temp": 18.5},
                  "weather": [{"description": "sunny"}]
              },
              {
                  "dt_txt": "2024-01-02 12:00:00",
                  "main": {"temp": 17.2},
                  "weather": [{"description": "cloudy"}]
              }
          ]
      }

  @pytest.mark.asyncio
  async def test_fetch_weather(mock_weather_response):
      with patch('requests.Session.get') as mock_get:
          mock_get.return_value.json.return_value = mock_weather_response
          mock_get.return_value.raise_for_status = Mock()

          weather = await fetch_weather("London")

          assert weather["temperature"] == 20.5
          assert weather["conditions"] == "scattered clouds"
          assert weather["humidity"] == 65
          assert weather["wind_speed"] == 3.6
          assert "timestamp" in weather

  @pytest.mark.asyncio
  async def test_read_resource():
      with patch('weather_service.server.fetch_weather') as mock_fetch:
          mock_fetch.return_value = {
              "temperature": 20.5,
              "conditions": "clear sky",
              "timestamp": datetime.now().isoformat()
          }

          uri = AnyUrl("weather://London/current")
          result = await read_resource(uri)

          assert isinstance(result, str)
          assert "temperature" in result
          assert "clear sky" in result

  @pytest.mark.asyncio
  async def test_call_tool(mock_forecast_response):
      with patch('weather_service.server.http.get') as mock_get:
          mock_get.return_value.json.return_value = mock_forecast_response
          mock_get.return_value.raise_for_status = Mock()

          result = await call_tool("get_forecast", {"city": "London", "days": 2})

          assert len(result) == 1
          assert result[0].type == "text"
          forecast_data = json.loads(result[0].text)
          assert len(forecast_data) == 1
          assert forecast_data[0]["temperature"] == 18.5
          assert forecast_data[0]["conditions"] == "sunny"

  @pytest.mark.asyncio
  async def test_list_resources():
      resources = await list_resources()
      assert len(resources) == 1
      assert resources[0].name == f"Current weather in {DEFAULT_CITY}"
      assert resources[0].mimeType == "application/json"

  @pytest.mark.asyncio
  async def test_list_tools():
      tools = await list_tools()
      assert len(tools) == 1
      assert tools[0].name == "get_forecast"
      assert "city" in tools[0].inputSchema["properties"]
  ```
  </Step>
  <Step title="Run tests">
  ```bash
  uv add --dev pytest pytest-asyncio
  uv run pytest
  ```
  </Step>
</Steps>

## Next steps

<CardGroup cols={2}>
  <Card title="Architecture overview" icon="sitemap" href="/docs/concepts/architecture">
    Learn more about the MCP architecture
  </Card>

  <Card title="Python SDK" icon="python" href="/api-reference/python/class-reference">
    Read more about the Python SDK
  </Card>
</CardGroup>
